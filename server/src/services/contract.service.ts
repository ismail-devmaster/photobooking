// src/services/contract.service.ts
import { prisma } from '../config/prisma';
import PDFDocument from 'pdfkit';
import path from 'path';
import { promises as fsPromises } from 'fs';
import { createWriteStream } from 'fs';
import { v4 as uuidv4 } from 'uuid';
import { ContractStatus, NotificationType } from '@prisma/client';
import * as notificationService from './notification.service';

const APP_BASE_URL = process.env.APP_BASE_URL?.replace(/\/$/, '') || 'http://localhost:4000';
const CONTRACTS_ROOT = path.join(process.cwd(), 'uploads', 'contracts');

async function ensureDir(dir: string) {
  await fsPromises.mkdir(dir, { recursive: true });
}

/**
 * Helper: write a PDF file for a contract given content and optional signature images.
 * Returns absolute file path.
 */
export async function renderContractPdfToFile(opts: {
  contractId: string;
  bookingId: string;
  clientName: string | null;
  photographerName: string | null;
  termsHtmlOrText?: string;
  signatureClientPath?: string | null;
  signaturePhotographerPath?: string | null;
}) {
  const {
    contractId,
    bookingId,
    clientName,
    photographerName,
    termsHtmlOrText,
    signatureClientPath,
    signaturePhotographerPath,
  } = opts;

  const contractDir = path.join(CONTRACTS_ROOT, bookingId);
  await ensureDir(contractDir);

  const outPath = path.join(contractDir, `${contractId}.pdf`);

  return new Promise<string>((resolve, reject) => {
    try {
      const doc = new PDFDocument({ size: 'A4', margin: 50 });
      doc.pipe(createWriteStream(outPath));

      // Header
      doc.fontSize(18).text('Photography Service Contract', { align: 'center' });
      doc.moveDown();

      // Parties
      doc.fontSize(12);
      doc.text(`Booking ID: ${bookingId}`);
      doc.moveDown(0.5);
      doc.text(`Client: ${clientName ?? '—'}`);
      doc.text(`Photographer: ${photographerName ?? '—'}`);
      doc.moveDown();

      // Terms / body
      doc.fontSize(11);
      const bodyText =
        termsHtmlOrText ??
        `This contract is made between ${clientName ?? 'Client'} and ${photographerName ?? 'Photographer'} for the photography services described in the booking. The parties agree to the terms and conditions stated herein.`;
      doc.text(bodyText, { align: 'left' });
      doc.moveDown(2);

      // Signatures section
      doc.fontSize(12).text('Signatures', { underline: true });
      doc.moveDown(0.5);

      const sigYStart = doc.y;

      // Left: Client
      doc.fontSize(10).text('Client signature:', { continued: true });
      if (signatureClientPath) {
        try {
          doc.image(signatureClientPath, { fit: [150, 60] });
        } catch (e) {
          // ignore image errors
          doc.text(' [signature image could not be embedded] ');
        }
      } else {
        doc.text(' ____________________________');
      }
      doc.moveDown();

      // Name & date
      doc.text(`Name: ${clientName ?? '—'}`);
      doc.moveDown(1);

      // Photographer
      doc.text('Photographer signature:');
      if (signaturePhotographerPath) {
        try {
          doc.image(signaturePhotographerPath, { fit: [150, 60] });
        } catch (e) {
          doc.text(' [signature image could not be embedded] ');
        }
      } else {
        doc.text(' ____________________________');
      }
      doc.moveDown();
      doc.text(`Name: ${photographerName ?? '—'}`);
      doc.moveDown(2);

      // Footer
      doc
        .fontSize(9)
        .text(`Generated by ${APP_BASE_URL} — Contract ID: ${contractId}`, { align: 'center' });

      doc.end();

      // Wait until file exists (since stream created from node fs)
      // Use interval check for file existence as a small robust solution
      const checkInterval = setInterval(async () => {
        try {
          await fsPromises.access(outPath);
          clearInterval(checkInterval);
          resolve(outPath);
        } catch (e) {
          // still writing
        }
      }, 100);
    } catch (err) {
      reject(err);
    }
  });
}

/**
 * Generate a contract for a booking.
 * - validates booking exists
 * - ensures user is participant (client/photographer) or admin (we assume caller has been validated by controller)
 * - creates Contract record (if not exists) and generates PDF file, updates pdfUrl
 */
export async function generateContractForBooking(bookingId: string, actorUserId: string) {
  // load booking with participants
  const booking = await prisma.booking.findUnique({
    where: { id: bookingId },
    include: {
      client: { select: { id: true, name: true, email: true } },
      photographer: { include: { user: { select: { id: true, name: true, email: true } } } },
    },
  });
  if (!booking) throw new Error('Booking not found');

  // permission: caller must be client or photographer or admin - controller should ensure, but we still keep check minimal:
  const photographerUserId = booking.photographer?.user?.id ?? null;
  const isParticipant = booking.clientId === actorUserId || photographerUserId === actorUserId;

  if (!isParticipant) {
    // allow generating from server/admin flows, throw if not participant
    // you can change this to allow admin role in controller
    // For now we allow only participants
    throw new Error('Forbidden: only booking participants can generate contract');
  }

  // if contract exists -> regenerate pdf (overwrite)
  let contract = await prisma.contract.findUnique({ where: { bookingId } });

  // create contract if missing
  if (!contract) {
    contract = await prisma.contract.create({
      data: {
        bookingId,
        status: ContractStatus.GENERATED,
        pdfUrl: '', // placeholder
      },
    });
  } else {
    // update status back to GENERATED if previously void etc.
    await prisma.contract.update({
      where: { id: contract.id },
      data: { status: ContractStatus.GENERATED },
    });
  }

  // ensure directories
  const contractDir = path.join(CONTRACTS_ROOT, bookingId);
  await ensureDir(contractDir);

  // render PDF
  const pdfPath = await renderContractPdfToFile({
    contractId: contract.id,
    bookingId,
    clientName: booking.client?.name ?? null,
    photographerName: booking.photographer?.user?.name ?? null,
    termsHtmlOrText: undefined, // optionally fetch template
  });

  // compute public url
  const relative = path
    .relative(path.join(process.cwd(), 'uploads'), pdfPath)
    .split(path.sep)
    .join('/');
  const pdfUrl = `${APP_BASE_URL}/uploads/${relative}`;

  // update contract pdfUrl
  const updated = await prisma.contract.update({
    where: { id: contract.id },
    data: {
      pdfUrl,
      status: ContractStatus.GENERATED,
    },
  });

  return { contract: updated, pdfPath };
}

/**
 * Sign a contract:
 * - accepts base64 dataURL signature
 * - validates signer is client or photographer for the booking
 * - stores signature file
 * - regenerates PDF embedding signatures
 * - updates contract status: PARTIALLY_SIGNED or SIGNED and sets signedAt when both signed
 * - creates notification to the other party
 */
export async function signContract(
  contractId: string,
  signerUserId: string,
  signatureDataUrl: string,
  signerName?: string,
) {
  const contract = await prisma.contract.findUnique({
    where: { id: contractId },
    include: { booking: { include: { client: true, photographer: { include: { user: true } } } } },
  });
  if (!contract) throw new Error('Contract not found');

  const booking = contract.booking;
  if (!booking) throw new Error('Contract has no booking attached');

  const clientId = booking.clientId;
  const photographerUserId = booking.photographer?.user?.id ?? null;

  let role: 'client' | 'photographer' | null = null;
  if (signerUserId === clientId) role = 'client';
  else if (signerUserId === photographerUserId) role = 'photographer';
  else role = null;

  if (!role) throw new Error('Only booking client or photographer can sign this contract');

  // parse base64 dataUrl
  const match = signatureDataUrl.match(/^data:(image\/png|image\/jpeg);base64,(.+)$/);
  let base64Payload = signatureDataUrl;
  let ext = 'png';
  if (match) {
    const mime = match[1];
    base64Payload = match[2];
    ext = mime === 'image/jpeg' ? 'jpg' : 'png';
  } else {
    // maybe raw base64, keep as png
    ext = 'png';
  }

  // ensure contract dir
  const contractDir = path.join(CONTRACTS_ROOT, booking.id);
  await ensureDir(contractDir);

  const signatureFileName =
    role === 'client' ? `signature-client.${ext}` : `signature-photographer.${ext}`;
  const signaturePath = path.join(contractDir, signatureFileName);

  // write file
  const buffer = Buffer.from(base64Payload, 'base64');
  // safety: limit size (e.g., 200 KB)
  const MAX_SIG_SIZE = 200 * 1024;
  if (buffer.length > MAX_SIG_SIZE) throw new Error('Signature image too large');

  await fsPromises.writeFile(signaturePath, buffer);

  // determine if both signatures exist
  const clientSigPath = path.join(contractDir, `signature-client.png`);
  const photogSigPath = path.join(contractDir, `signature-photographer.png`);
  // But extension may be jpg for one; check both png/jpg variations
  const possibleClient = await findExistingSignatureFile(contractDir, 'client');
  const possiblePhotog = await findExistingSignatureFile(contractDir, 'photographer');

  // regenerate pdf with the available signatures (use actual found files)
  const signatureClientPath = possibleClient ?? null;
  const signaturePhotographerPath = possiblePhotog ?? null;

  const newPdfPath = await renderContractPdfToFile({
    contractId: contract.id,
    bookingId: booking.id,
    clientName: booking.client?.name ?? null,
    photographerName: booking.photographer?.user?.name ?? null,
    signatureClientPath,
    signaturePhotographerPath,
  });

  const relative = path
    .relative(path.join(process.cwd(), 'uploads'), newPdfPath)
    .split(path.sep)
    .join('/');
  const pdfUrl = `${APP_BASE_URL}/uploads/${relative}`;

  // update contract status in DB
  // if both present => SIGNED and signedAt set, else PARTIALLY_SIGNED
  const bothSigned = !!signatureClientPath && !!signaturePhotographerPath;
  const newStatus = bothSigned ? ContractStatus.SIGNED : ContractStatus.PARTIALLY_SIGNED;

  const updated = await prisma.contract.update({
    where: { id: contract.id },
    data: {
      pdfUrl,
      status: newStatus,
      signedAt: bothSigned ? new Date() : undefined,
    },
  });

  // notify the other party via notificationService (this also emits real-time)
  const otherUserId = signerUserId === clientId ? photographerUserId : clientId;
  if (otherUserId) {
    await notificationService.createNotification(otherUserId, NotificationType.CONTRACT_SIGNED, {
      contractId: contract.id,
      bookingId: booking.id,
      signedBy: role,
      signerName: signerName ?? null,
    });
  }

  return updated;
}

/**
 * Utility: search for signature files with png/jpg extension for role
 */
async function findExistingSignatureFile(contractDir: string, role: 'client' | 'photographer') {
  const pngPath = path.join(contractDir, `signature-${role}.png`);
  const jpgPath = path.join(contractDir, `signature-${role}.jpg`);
  try {
    await fsPromises.access(pngPath);
    return pngPath;
  } catch {}
  try {
    await fsPromises.access(jpgPath);
    return jpgPath;
  } catch {}
  return null;
}

/**
 * Get contract by id
 */
export async function getContract(contractId: string) {
  return prisma.contract.findUnique({
    where: { id: contractId },
    include: { booking: { include: { client: true, photographer: { include: { user: true } } } } },
  });
}
